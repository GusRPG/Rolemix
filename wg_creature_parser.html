<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wrath & Glory Parser</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Share Tech Mono', monospace;
            background: #000;
            color: #00ff41;
            min-height: 100vh;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(0, 255, 100, 0.03) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(0, 100, 255, 0.03) 0%, transparent 20%),
                linear-gradient(45deg, #0a0a0a 25%, #111 25%, #111 50%, #0a0a0a 50%, #0a0a0a 75%, #111 75%);
            background-size: 100px 100px;
            overflow-x: hidden;
            position: relative;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 10;
        }

        .header-bar {
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 70px;
            background: linear-gradient(to bottom, #00ff41 0%, #00cc33 100%);
            box-shadow: 
                0 0 20px #00ff41,
                inset 0 0 15px rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 25px;
            z-index: 100;
            border-bottom: 3px solid #00ff41;
            backdrop-filter: blur(2px);
        }

        .header-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: #000;
            text-shadow: 0 0 8px #00ff41;
            letter-spacing: 3px;
        }

        .controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .lang-toggle {
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #00ff41;
            color: #00ff41;
            padding: 8px 12px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.9rem;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
            transition: all 0.2s ease;
            text-shadow: 0 0 5px #00ff41;
        }

        .lang-toggle:hover {
            background: #00ff41;
            color: #000;
            box-shadow: 0 0 15px #00ff41;
            text-shadow: none;
        }

        .main-content {
            margin-top: 90px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ff41;
            box-shadow: 
                0 0 20px rgba(0, 255, 65, 0.2),
                inset 0 0 30px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            position: relative;
            z-index: 10;
        }

        h1 {
            color: #00ff41;
            text-align: center;
            margin-bottom: 20px;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 10px #00ff41;
            letter-spacing: 2px;
        }

        .hint {
            text-align: center;
            font-size: 0.9rem;
            color: #00cc33;
            margin-bottom: 20px;
            text-shadow: 0 0 5px #00ff41;
            font-style: italic;
        }

        .settings {
            background: rgba(0, 20, 0, 0.5);
            border: 1px dashed #00ff41;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 0;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.1);
        }

        .settings h3 {
            color: #00ff41;
            margin-bottom: 10px;
            text-shadow: 0 0 5px #00ff41;
        }

        .settings label {
            color: #00ff41;
            font-size: 0.85rem;
            margin-right: 15px;
            display: inline-block;
            margin-bottom: 8px;
        }

        .settings input[type="checkbox"] {
            accent-color: #00ff41;
            transform: scale(1.2);
            margin-right: 5px;
        }

        .row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .col {
            flex: 1;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #00ff41;
            padding: 15px;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.1);
        }

        .col h3 {
            color: #00ff41;
            margin-bottom: 10px;
            text-shadow: 0 0 5px #00ff41;
            font-size: 1rem;
        }

        textarea {
            width: 100%;
            height: 320px;
            background: #000;
            color: #00ff41;
            border: 1px solid #00ff41;
            padding: 12px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 12px;
            resize: vertical;
            box-shadow: inset 0 0 15px rgba(0, 255, 65, 0.1);
            text-shadow: 0 0 3px #00ff41;
        }

        textarea::placeholder {
            color: #006622;
            opacity: 0.8;
        }

        button {
            background: #000;
            color: #00ff41;
            border: 1px solid #00ff41;
            padding: 10px 18px;
            margin: 8px 8px 8px 0;
            cursor: pointer;
            font-weight: bold;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.9rem;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
            transition: all 0.2s ease;
            text-shadow: 0 0 5px #00ff41;
        }

        button:hover {
            background: #00ff41;
            color: #000;
            box-shadow: 0 0 15px #00ff41;
            text-shadow: none;
        }

        pre {
            background: #000;
            color: #00ff41;
            border: 1px solid #00ff41;
            padding: 15px;
            max-height: 400px;
            overflow: auto;
            font-size: 11px;
            font-family: 'Share Tech Mono', monospace;
            white-space: pre-wrap;
            box-shadow: inset 0 0 15px rgba(0, 255, 65, 0.1);
            text-shadow: 0 0 3px #00ff41;
            line-height: 1.4;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            margin-top: 20px;
            border: 1px solid #00ff41;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.1);
        }

        table th, table td {
            border: 1px solid #00ff41;
            padding: 10px;
            text-align: left;
        }

        table th {
            background: rgba(0, 255, 65, 0.1);
            color: #00ff41;
            text-shadow: 0 0 5px #00ff41;
            font-weight: bold;
        }

        table tr:hover {
            background: rgba(0, 255, 65, 0.05);
        }

        .actions {
            margin-top: 30px;
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px dashed #00ff41;
        }

        #info {
            margin-top: 15px;
            font-size: 1rem;
            color: #00ff41;
            text-shadow: 0 0 5px #00ff41;
        }

        /* EFECTO DE INTERFERENCIA - LÍNEA QUE BAJA */
        .scanline {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            background: linear-gradient(to bottom, transparent 50%, rgba(0, 255, 65, 0.03) 50%);
            background-size: 100% 4px;
            z-index: 1000;
            animation: scan 8s linear infinite;
        }

        @keyframes scan {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }

        .glitch {
            animation: glitch 3s infinite;
        }

        @keyframes glitch {
            0%, 100% { text-shadow: 0 0 5px #00ff41; }
            50% { text-shadow: 2px 0 0 #ff00ff, -2px 0 0 #00ffff; }
        }

        .tilde {
            font-family: 'Orbitron', sans-serif;
        }
    </style>
</head>
<body>
    <!-- EFECTO DE LÍNEA QUE BAJA (SCANLINE) -->
    <div class="scanline"></div>

    <div class="container">
        <div class="header-bar">
            <div class="header-title glitch">W&G COMPENDIUM PARSER v9.9</div>
            <div class="controls">
                <div id="langToggle" class="lang-toggle">ESP</div>
            </div>
        </div>

        <div class="main-content">
            <h1 data-en="Wrath & Glory Compendium Parser" data-es="Wrath & Glory Compendium Parser">Wrath & Glory Compendium Parser</h1>
            
            <div class="hint" id="separatorHint">
                <span data-en="Use º or ~ at the start of each new creature. If none is used at the beginning, it will be treated as a single entry."
                      data-es="Usa º o ~ al inicio de cada nueva criatura. Si no se usa al principio, se tratará como una sola entrada.">
                </span>
            </div>

            <div class="settings">
                <h3 data-en="AutoCalc Settings" data-es="Configuración de AutoCalc">AutoCalc Settings</h3>
                <label><input type="checkbox" id="toggleAll" checked> <span data-en="Toggle All" data-es="Activar/Desactivar Todos">Toggle All</span></label><br>
                <label><input type="checkbox" id="generateMetaCurrencies" checked> generateMetaCurrencies</label>
                <label><input type="checkbox" id="defence" checked> defence</label>
                <label><input type="checkbox" id="resilience" checked> resilience</label>
                <label><input type="checkbox" id="shock" checked> shock</label>
                <label><input type="checkbox" id="awareness" checked> awareness</label>
                <label><input type="checkbox" id="resolve" checked> resolve</label>
                <label><input type="checkbox" id="determination" checked> determination</label>
                <label><input type="checkbox" id="wounds" checked> wounds</label>
                <label><input type="checkbox" id="conviction" checked> conviction</label>
            </div>

            <div class="row">
                <div class="col">
                    <h3 data-en="Input (start name with º or <span class=&quot;tilde&quot;>~</span> for multiple creatures)" data-es="Input (iniciar nombre con º o <span class=&quot;tilde&quot;>~</span> para multiples criaturas)">Input (start name with º or <span class="tilde">~</span> for multiple creatures)</h3>
                    <textarea id="input" placeholder="º or ~ CREATURE NAME..."></textarea>
                    <button id="importBtn" data-en="Import" data-es="Importar">Import</button>
                    <button id="clearBtn" data-en="Clear" data-es="Limpiar">Clear</button>
                </div>
                <div class="col">
                    <h3 data-en="Debug" data-es="Debug">Debug</h3>
                    <pre id="debug"></pre>
                </div>
            </div>

            <h3 data-en="Creatures" data-es="Criaturas">Creatures</h3>
            <table>
                <thead>
                    <tr>
                        <th data-en="Name" data-es="Nombre">Name</th>
                        <th data-en="Tier" data-es="Tier">Tier</th>
                        <th data-en="Items" data-es="Items">Items</th>
                        <th data-en="Actions" data-es="Acciones">Actions</th>
                    </tr>
                </thead>
                <tbody id="tableBody"></tbody>
            </table>

            <div class="actions">
                <button id="downloadBtn" data-en="Download JSON" data-es="Descargar JSON">Download JSON</button>
                <button id="copyBtn" data-en="Copy JSON" data-es="Copiar JSON">Copy JSON</button>
                <button id="clearAllBtn" data-en="Delete All" data-es="Borrar Todo">Delete All</button>
                <p id="info">0 <span data-en="creature(s)" data-es="criatura(s)">creature(s)</span></p>
            </div>
        </div>
    </div>

    <script>
        let creatures = [];
        let debugLog = [];
        let currentLang = 'en';

        const translations = {
            en: {
                separatorHint: "Use º or ~ at the start of each new creature. If none is used at the beginning, it will be treated as a single entry.",
                inputHint: "Input (start name with º or <span class=\"tilde\">~</span> for multiple creatures)",
                inputPlaceholder: "º or ~ CREATURE NAME...",
                toggleAll: "Toggle All",
                import: "Import",
                clear: "Clear",
                download: "Download JSON",
                copy: "Copy JSON",
                deleteAll: "Delete All",
                creatures: "Creatures",
                items: "Items",
                actions: "Actions",
                name: "Name",
                tier: "Tier",
                infoCreatures: "creature(s)",
                skills: {
                    'athletics': 'Athletics',
                    'awareness': 'Awareness',
                    'ballisticSkill': 'Ballistic Skill',
                    'cunning': 'Cunning',
                    'deception': 'Deception',
                    'insight': 'Insight',
                    'intimidation': 'Intimidation',
                    'investigation': 'Investigation',
                    'leadership': 'Leadership',
                    'medicae': 'Medicae',
                    'persuasion': 'Persuasion',
                    'pilot': 'Pilot',
                    'psychicMastery': 'Psychic Mastery',
                    'scholar': 'Scholar',
                    'stealth': 'Stealth',
                    'survival': 'Survival',
                    'tech': 'Tech',
                    'weaponSkill': 'Weapon Skill'
                },
                sections: {
                    'ARMAS': 'WEAPONS',
                    'ARMADURAS': 'ARMOUR',
                    'ABILITIES': 'ABILITIES',
                    'TALENTOS': 'TALENTOS',
                    'KEYWORDS': 'KEYWORDS'
                }
            },
            es: {
                separatorHint: "Usa º o ~ al inicio de cada nueva criatura. Si no se usa al principio, se tratará como una sola entrada.",
                inputHint: "Input (iniciar nombre con º o <span class=\"tilde\">~</span> para multiples criaturas)",
                inputPlaceholder: "º o ~ NOMBRE CRIATURA...",
                toggleAll: "Activar/Desactivar Todos",
                import: "Importar",
                clear: "Limpiar",
                download: "Descargar JSON",
                copy: "Copiar JSON",
                deleteAll: "Borrar Todo",
                creatures: "Criaturas",
                items: "Items",
                actions: "Acciones",
                name: "Nombre",
                tier: "Tier",
                infoCreatures: "criatura(s)",
                skills: {
                    'athletics': 'Atletismo',
                    'awareness': 'Vigilancia',
                    'ballisticSkill': 'Ballistic Skill',
                    'cunning': 'Astucia',
                    'deception': 'Engaño',
                    'insight': 'Perspicacia',
                    'intimidation': 'Intimidación',
                    'investigation': 'Investigación',
                    'leadership': 'Liderazgo',
                    'medicae': 'Medicae',
                    'persuasion': 'Persuasión',
                    'pilot': 'Pilotaje',
                    'psychicMastery': 'Dominio Psíquico',
                    'scholar': 'Erudición',
                    'stealth': 'Sigilo',
                    'survival': 'Supervivencia',
                    'tech': 'Técnica',
                    'weaponSkill': 'Weapon Skill'
                },
                sections: {
                    'WEAPONS': 'ARMAS',
                    'ARMOUR': 'ARMADURAS',
                    'ABILITIES': 'HABILIDADES',
                    'TALENTS': 'TALENTOS',
                    'KEYWORDS': 'KEYWORDS'
                }
            }
        };

        function updateHints() {
            const hint = document.getElementById('separatorHint');
            const inputHint = document.querySelector('h3[data-en*="Input"]');
            const placeholder = document.getElementById('input');
            
            hint.innerHTML = `<span data-en="${translations.en.separatorHint}" data-es="${translations.es.separatorHint}">${translations[currentLang].separatorHint}</span>`;
            inputHint.innerHTML = translations[currentLang].inputHint;
            placeholder.placeholder = translations[currentLang].inputPlaceholder;
        }

        function switchLanguage(lang) {
            currentLang = lang;
            document.querySelectorAll('[data-en]').forEach(el => {
                el.innerHTML = el.getAttribute(`data-${lang}`);
            });
            document.getElementById('langToggle').textContent = lang === 'en' ? 'ESP' : 'ENG';
            updateHints();
            if (creatures.length > 0) updateTable();
        }

        document.getElementById('langToggle').addEventListener('click', () => {
            switchLanguage(currentLang === 'en' ? 'es' : 'en');
        });

        const skillMap = {
            "athletics": { key: "athletics", attr: "strength" },
            "awareness": { key: "awareness", attr: "intellect" },
            "ballistic skill": { key: "ballisticSkill", attr: "agility" },
            "ballistic": { key: "ballisticSkill", attr: "agility" },
            "cunning": { key: "cunning", attr: "fellowship" },
            "deception": { key: "deception", attr: "fellowship" },
            "insight": { key: "insight", attr: "fellowship" },
            "intimidation": { key: "intimidation", attr: "willpower" },
            "investigation": { key: "investigation", attr: "intellect" },
            "leadership": { key: "leadership", attr: "willpower" },
            "medicae": { key: "medicae", attr: "intellect" },
            "persuasion": { key: "persuasion", attr: "fellowship" },
            "pilot": { key: "pilot", attr: "agility" },
            "psychic mastery": { key: "psychicMastery", attr: "willpower" },
            "psychic": { key: "psychicMastery", attr: "willpower" },
            "scholar": { key: "scholar", attr: "intellect" },
            "stealth": { key: "stealth", attr: "agility" },
            "survival": { key: "survival", attr: "willpower" },
            "tech": { key: "tech", attr: "intellect" },
            "weapon skill": { key: "weaponSkill", attr: "initiative" },
            "weapon": { key: "weaponSkill", attr: "initiative" }
        };

        function generateId() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < 16; i++) result += chars.charAt(Math.floor(Math.random() * chars.length));
            return result;
        }

        function isSectionHeader(line) {
            if (!line) return false;
            const trimmed = line.trim();
            if (!/^[A-Z]/.test(trimmed)) return false;
            if (trimmed.includes(':')) return false;
            const patterns = [
                /^(KEYWORDS|SKILLS|BONUSES|ABILITIES|ACTION|MOB|DETERMINATION|RUIN|ANNIHILATION|NOTES|COMPLICATION)/i,
                /^(Conviction|Resolve|Speed|Size|Defence|Wounds|Shock|Resilience)/i,
                /^(Tier|S T A I)/i,
                /^[A-Z\s]+$/
            ];
            return patterns.some(p => p.test(trimmed));
        }

        function createItem(type, name, content, abilityType = "", equipped = true) {
            const item = {
                "type": type, "name": name, "_id": generateId(), "effects": [], "folder": null, "sort": 0,
                "flags": { "core": {} },
                "_stats": { "coreVersion": "13.350", "systemId": "wrath-and-glory", "systemVersion": "7.3.0",
                            "createdTime": Date.now(), "modifiedTime": Date.now(), "lastModifiedBy": "mwx452c2tE9lwAVm" },
                "ownership": { "default": 0 }, "img": ""
            };

            if (type === "keyword") {
                item.img = "modules/wng-core/assets/ui/aquila-white.webp";
                item.system = { "description": "" };
            } else if (type === "armour") {
                item.img = "modules/wng-core/assets/icons/armour/armour.webp";
                const m = content.match(/(\d+)/);
                const rating = m ? parseInt(m[1]) : 0;
                item.system = { "quantity": 1, "rarity": "common", "description": "", "value": 0, "keywords": "", "equipped": true,
                                "rating": rating, "base": 0, "traits": { "list": [] }, "invulnerable": false };
            } else if (type === "talent") {
                item.img = "modules/wng-core/assets/icons/talents/talent.webp";
                item.system = { "effect": "", "cost": 0, "requirements": "", "description": `<p>${content}</p>`, "display": true,
                                "test": { "self": false, "dn": null, "type": "" },
                                "damage": { "enabled": false, "attribute": "strength", "base": 0, "bonus": 0, "rank": 0,
                                            "ed": { "base": 0, "bonus": 0, "rank": 0 },
                                            "ap": { "base": 0, "bonus": 0, "rank": 0 },
                                            "otherDamage": { "mortal": "0", "wounds": "0", "shock": "0" } },
                                "traits": { "list": [] }, "uses": {} };
            } else if (type === "ability") {
                item.img = "modules/wng-core/assets/icons/abilities/adeptus-astartes.webp";
                item.sort = (abilityType === "ruin") ? 500000 : 0;
                item.system = { "effect": "", "cost": 0, "requirements": "", "description": `<p>${content}</p>`, "display": true,
                                "type": abilityType, "traits": { "list": [] },
                                "damage": { "base": 0, "bonus": 0, "rank": 0,
                                            "ed": { "base": 0, "bonus": 0, "rank": 0 },
                                            "ap": { "base": 0, "bonus": 0, "rank": 0 },
                                            "otherDamage": { "mortal": "", "wounds": "", "shock": "" }, "enabled": false,
                                            "attribute": "strength" },
                                "test": { "self": false, "dn": null, "type": "" } };
            } else if (type === "weapon") {
                const isRanged = content.toLowerCase().includes("range") && !content.match(/range\s*1\b/i);
                const category = isRanged ? "ranged" : "melee";
                let img = "modules/wng-core/assets/icons/weapons/melee-weapon.webp";
                if (name.toLowerCase().includes("boltgun")) img = "modules/wng-core/assets/icons/weapons/boltgun.webp";
                else if (name.toLowerCase().includes("knife")) img = "modules/wng-core/assets/icons/weapons/astartes-combat-knife.webp";
                else if (category === "ranged") img = "modules/wng-core/assets/icons/weapons/ranged-weapon.webp";
                item.img = img;

                let baseDmg = 0, edDmg = 0, apDmg = 0;
                const dmgMatch = content.match(/(\d+)\s*\+(\d+)\s*ED/i);
                if (dmgMatch) { baseDmg = parseInt(dmgMatch[1]); edDmg = parseInt(dmgMatch[2]); }
                const apMatch = content.match(/AP\s*(-?\d+)/i);
                if (apMatch) apDmg = parseInt(apMatch[1]);

                let rangeShort = 0, rangeMed = 0, rangeLong = 0, meleeDist = 1;
                const rangeFullMatch = content.match(/Range\s+(\d+)\s*[–-]\s*(\d+)\s*[–-]\s*(\d+)/i);
                const rangeSingleMatch = content.match(/Range\s+(\d+)/i);
                if (rangeFullMatch) {
                    rangeShort = parseInt(rangeFullMatch[1]);
                    rangeMed   = parseInt(rangeFullMatch[2]);
                    rangeLong  = parseInt(rangeFullMatch[3]);
                } else if (rangeSingleMatch && !content.match(/range\s*1\b/i)) {
                    rangeMed = parseInt(rangeSingleMatch[1]);
                    const half = Math.floor(rangeMed / 2);
                    rangeShort = rangeMed - half;
                    rangeLong = rangeMed + half;
                } else if (content.toLowerCase().includes("range 1")) {
                    rangeShort = rangeMed = rangeLong = 0; meleeDist = 1;
                }

                let salvo = 0;
                const salvoMatch = content.match(/Salvo[,\s]+(\d+)/i);
                if (salvoMatch) salvo = parseInt(salvoMatch[1]);

                const traits = [];
                const parts = content.split('/');
                if (parts.length > 1) {
                    let traitsPart = parts.slice(-1)[0].trim();
                    for (let p = parts.length - 2; p >= 0; p--) {
                        if (!parts[p].trim().match(/^(Range|Salvo|AP|Blast)/i)) {
                            traitsPart = parts[p].trim() + ' / ' + traitsPart;
                        } else break;
                    }
                    if (traitsPart) {
                        traitsPart.split(',').forEach(t => {
                            const tr = t.trim().toLowerCase();
                            const rating = tr.match(/(.+)\s*\(([^)]+)\)/);
                            traits.push(rating ? { "name": rating[1].trim(), "rating": rating[2].trim() }
                                               : { "name": tr });
                        });
                    }
                }

                item.system = {
                    "quantity": 1, "rarity": "uncommon", "description": `<p>${content}</p>`, "value": 0, "keywords": "", "equipped": equipped,
                    "attack": { "base": 0, "bonus": 0, "rank": "none" },
                    "damage": { "base": baseDmg, "bonus": 0, "rank": 0, "enabled": false, "attribute": "strength",
                                "ed": { "base": edDmg, "bonus": 0, "rank": 0 },
                                "ap": { "base": apDmg, "bonus": 0, "rank": 0 },
                                "otherDamage": { "mortal": "0", "wounds": "0", "shock": "0" } },
                    "category": category,
                    "range": { "short": rangeShort, "medium": rangeMed, "long": rangeLong, "melee": meleeDist, "thrown": null },
                    "ammo": { "id": "" }, "salvo": salvo, "traits": { "list": traits },
                    "upgrades": [], "otherDamage": {}, "combi": {}, "twinned": false
                };
            }
            return item;
        }

        function getSettings() {
            return {
                generateMetaCurrencies: document.getElementById('generateMetaCurrencies').checked,
                autoCalc: {
                    defence: document.getElementById('defence').checked,
                    resilience: document.getElementById('resilience').checked,
                    shock: document.getElementById('shock').checked,
                    awareness: document.getElementById('awareness').checked,
                    resolve: document.getElementById('resolve').checked,
                    determination: document.getElementById('determination').checked,
                    wounds: document.getElementById('wounds').checked,
                    conviction: document.getElementById('conviction').checked
                }
            };
        }

        document.getElementById('toggleAll').onclick = function() {
            const checked = this.checked;
            ['generateMetaCurrencies','defence','resilience','shock','awareness','resolve','determination','wounds','conviction']
                .forEach(id => document.getElementById(id).checked = checked);
        };

        function parseCreature(text) {
            debugLog = [];
            log("=== PARSING START ===");
            const lines = text.split('\n').map(l => l.trim()).filter(l => l);
            if (!lines.length) return null;

            let nameIndex = 0;
            while (nameIndex < lines.length && !lines[nameIndex].match(/^(Tier|Threat|Keywords|S T A I)/i)) nameIndex++;
            const name = lines.slice(0, nameIndex).join(' ').replace(/^[º~]/, '').trim().toUpperCase() || "UNKNOWN";
            log(`Creature name: ${name}`);

            const skillsTemplate = {};
            Object.entries(skillMap).forEach(([k, v]) => {
                skillsTemplate[v.key] = { "label": "SKILL." + v.key.toUpperCase(), "attribute": v.attr,
                                          "rating": 0, "base": 0, "bonus": 0, "cost": 0, "total": 0 };
            });

            const settings = getSettings();
            const creature = {
                "name": name, "type": "threat", "img": "modules/wng-core/assets/images/filler5.webp",
                "items": [], "effects": [], "folder": null, "flags": {}, "_id": generateId(),
                "_stats": { "coreVersion": "13.350", "systemId": "wrath-and-glory", "systemVersion": "7.3.0",
                            "createdTime": Date.now(), "modifiedTime": Date.now(), "lastModifiedBy": "mwx452c2tE9lwAVm" },
                "ownership": { "default": 0 },
                "system": {
                    "attributes": {
                        "strength":     { "label": "ATTRIBUTE.STRENGTH",     "rating": 0, "base": 1, "bonus": 0, "cost": 0, "total": 0 },
                        "toughness":    { "label": "ATTRIBUTE.TOUGHNESS",    "rating": 0, "base": 1, "bonus": 0, "cost": 0, "total": 0 },
                        "agility":      { "label": "ATTRIBUTE.AGILITY",      "rating": 0, "base": 1, "bonus": 0, "cost": 0, "total": 0 },
                        "initiative":   { "label": "ATTRIBUTE.INITIATIVE",   "rating": 0, "base": 1, "bonus": 0, "cost": 0, "total": 0 },
                        "willpower":    { "label": "ATTRIBUTE.WILLPOWER",    "rating": 0, "base": 1, "bonus": 0, "cost": 0, "total": 0 },
                        "intellect":    { "label": "ATTRIBUTE.INTELLECT",    "rating": 0, "base": 1, "bonus": 0, "cost": 0, "total": 0 },
                        "fellowship":   { "label": "ATTRIBUTE.FELLOWSHIP",   "rating": 0, "base": 1, "bonus": 0, "cost": 0, "total": 0 }
                    },
                    "skills": skillsTemplate,
                    "combat": {
                        "defence": { "bonus": 0, "total": 0 }, "resilience": { "bonus": 0, "total": 0 },
                        "wounds": { "value": 0, "bonus": 0, "max": 0 },
                        "determination": { "bonus": 0, "total": 0, "attribute": "toughness" },
                        "shock": { "value": 0, "bonus": 0, "max": 0 }, "resolve": { "bonus": 0, "total": 0 },
                        "conviction": { "bonus": 0, "total": 0 }, "size": "average", "speed": 6, "fly": 0,
                        "passiveAwareness": { "bonus": 0, "total": 0 }, "stealth": 0
                    },
                    "bio": { "species": "", "faction": "", "threat": { "first": "A", "second": "A", "third": "E", "fourth": "E", "fifth": "" } },
                    "advances": { "tier": 1, "rank": 1 }, "resources": { "ruin": 0 },
                    "mob": { "abilities": { "list": [] } }, "settings": settings, "notes": ""
                },
                "prototypeToken": {
                    "name": name, "displayName": 20, "actorLink": false, "width": 1, "height": 1,
                    "lockRotation": false, "rotation": 0, "alpha": 1, "disposition": 0, "displayBars": 20,
                    "bar1": { "attribute": "combat.wounds" }, "bar2": { "attribute": "combat.shock" },
                    "flags": {}, "randomImg": false,
                    "light": { "alpha": 0.25, "angle": 360, "bright": 0, "coloration": 1, "dim": 0, "luminosity": 0.5,
                               "saturation": 0, "contrast": 0, "shadows": 0,
                               "animation": { "speed": 5, "intensity": 5, "type": null, "reverse": false },
                               "darkness": { "min": 0, "max": 1 }, "attenuation": 0.5, "color": null, "negative": false, "priority": 0 },
                    "texture": { "src": "modules/wng-core/assets/tokens/tactical-space-marine.webp", "scaleX": 1, "scaleY": 1,
                                 "offsetX": 0, "offsetY": 0, "rotation": 0, "tint": "#ffffff", "anchorX": 0.5, "anchorY": 0.5,
                                 "fit": "contain", "alphaThreshold": 0.75 },
                    "sight": { "angle": 360, "enabled": false, "range": 0, "brightness": 1, "visionMode": "basic",
                               "color": null, "attenuation": 0.1, "saturation": 0, "contrast": 0 },
                    "detectionModes": [], "appendNumber": false, "prependAdjective": false,
                    "occludable": { "radius": 0 },
                    "ring": { "enabled": false, "colors": { "ring": null, "background": null }, "effects": 1,
                              "subject": { "scale": 1, "texture": null } },
                    "turnMarker": { "mode": 1, "animation": null, "src": null, "disposition": false },
                    "movementAction": null
                }
            };

            let i = nameIndex;
            let threatText = "";
            try {
                for (; i < lines.length; i++) {
                    const line = lines[i];
                    const nextLine = lines[i + 1] || '';

                    if (line.match(/^Tier\s+(\d+)/i)) {
                        creature.system.advances.tier = parseInt(RegExp.$1);
                        log(`Tier: ${RegExp.$1}`);
                    }

                    if (line.startsWith('KEYWORDS:')) {
                        let keyText = line.replace('KEYWORDS:', '').trim();
                        let j = i + 1;
                        while (j < lines.length && !isSectionHeader(lines[j])) {
                            if (lines[j].trim()) keyText += ', ' + lines[j].trim();
                            j++;
                        }
                        creature.system.bio.faction = keyText;
                        keyText.split(',').forEach(k => {
                            const kw = k.trim();
                            if (kw) { creature.items.push(createItem("keyword", kw, "")); log(`Keyword: ${kw}`); }
                        });
                        i = j - 1;
                        continue;
                    }

                    if (line.match(/^Threat\s+[AET]\s*\|\s*[AET]\s*\|\s*[AET]\s*\|\s*[AET]\s*\|\s*[AET]/i)) {
                        const threatMatch = line.match(/^Threat\s+([AET])\s*\|\s*([AET])\s*\|\s*([AET])\s*\|\s*([AET])\s*\|\s*([AET])/i);
                        if (threatMatch) {
                            const levels = ['first','second','third','fourth','fifth'];
                            threatMatch.slice(1).forEach((val, idx) => {
                                creature.system.bio.threat[levels[idx]] = val;
                            });
                            log(`Threat levels: ${threatMatch.slice(1).join('|')}`);
                        }

                        const afterPipe = line.replace(/^Threat\s+[AET\s|]+\s*/i, '').trim();
                        if (afterPipe) threatText = afterPipe;

                        let j = i + 1;
                        while (j < lines.length && !isSectionHeader(lines[j])) {
                            if (lines[j].trim()) threatText += ' ' + lines[j].trim();
                            j++;
                        }
                        i = j - 1;
                    }

                    if (line.match(/^S\s+T\s+A\s+I/i)) {
                        const vals = nextLine.split(/\s+/).map(v => parseInt(v) || 0);
                        const attrs = ['strength','toughness','agility','initiative','willpower','intellect','fellowship'];
                        if (vals.length >= 7) {
                            attrs.forEach((a, idx) => creature.system.attributes[a].base = vals[idx]);
                            log(`Attributes: S=${vals[0]} T=${vals[1]} A=${vals[2]} I=${vals[3]} Wil=${vals[4]} Int=${vals[5]} Fel=${vals[6]}`);
                        }
                        i++;
                    }

                    if (line.match(/^Defence\s+Wounds\s+Shock\s+Resilience/i)) {
                        const vals = nextLine.split(/\s+/).filter(v => v);
                        creature.system.combat.defence.total = parseInt(vals[0]) || 0;
                        creature.system.combat.wounds.max = parseInt(vals[1]) || 0; creature.system.combat.wounds.value = 0;
                        creature.system.combat.shock.max = (vals[2] === '–' || vals[2] === '-') ? 0 : parseInt(vals[2]) || 0;
                        creature.system.combat.shock.value = 0;
                        creature.system.combat.resilience.total = parseInt(vals[3]) || 0;
                        const arm = nextLine.match(/\(([^)]+)\)/);
                        if (arm) { const n = arm[1].split(':')[0].trim(); creature.items.push(createItem("armour", n, arm[1])); log(`Armour: ${n}`); }
                        log(`Combat (combined): Def=${vals[0]} Wounds=0/${vals[1]} Shock=0/${vals[2]} Res=${vals[3]}`);
                        i++;
                    } else if (line.match(/^Defence\s+Wounds\s+Shock/i) && !nextLine.match(/Resilience/i)) {
                        const vals = nextLine.split(/\s+/).filter(v => v);
                        creature.system.combat.defence.total = parseInt(vals[0]) || 0;
                        creature.system.combat.wounds.max = parseInt(vals[1]) || 0; creature.system.combat.wounds.value = 0;
                        creature.system.combat.shock.max = (vals[2] === '–' || vals[2] === '-') ? 0 : parseInt(vals[2]) || 0;
                        creature.system.combat.shock.value = 0;
                        log(`Combat: Def=${vals[0]} Wounds=0/${vals[1]} Shock=0/${vals[2]}`);
                        i++;
                    }

                    if (line.match(/^Resilience$/i)) {
                        const m = nextLine.match(/(\d+)/);
                        if (m) creature.system.combat.resilience.total = parseInt(m[1]);
                        const arm = nextLine.match(/\(([^)]+)\)/);
                        if (arm) { const n = arm[1].split(':')[0].trim(); creature.items.push(createItem("armour", n, arm[1])); log(`Armour: ${n}`); }
                        log(`Resilience: ${m ? m[1] : 0}`);
                        i++;
                    }

                    if (line.startsWith('SKILLS:')) {
                        let skillText = line.replace('SKILLS:', '').trim();
                        let j = i + 1;
                        while (j < lines.length && !lines[j].match(/^(BONUSES|ABILITIES|ACTION:|MOB|Conviction|DETERMINATION|RUIN|COMPLICATION|NOTES)/i)) {
                            skillText += ' ' + lines[j].trim();
                            j++;
                        }

                        skillText = skillText.replace(/\s+/g, ' ').trim();

                        const defMatch = skillText.match(/default\s+(\d+)/i);
                        if (defMatch) {
                            const def = parseInt(defMatch[1]);
                            Object.values(creature.system.skills).forEach(s => s.rating = def);
                            log(`Default skills: ${def}`);
                            skillText = skillText.replace(/default\s+\d+\s*,?\s*/i, '').trim();
                        }

                        if (skillText) {
                            const entries = [];
                            let current = '';
                            let parenLevel = 0;
                            for (let k = 0; k < skillText.length; k++) {
                                const ch = skillText[k];
                                if (ch === ',' && parenLevel === 0) {
                                    if (current.trim()) entries.push(current.trim());
                                    current = '';
                                } else {
                                    current += ch;
                                    if (ch === '(') parenLevel++;
                                    if (ch === ')') parenLevel--;
                                }
                            }
                            if (current.trim()) entries.push(current.trim());

                            entries.forEach(entry => {
                                const passiveMatch = entry.match(/\(.*?passive.*?(\d+).*?\)/i);
                                const passiveVal = passiveMatch ? parseInt(passiveMatch[1]) : null;
                                const cleanEntry = entry.replace(/\s*\(.*?\)/g, '').trim();

                                const parts = cleanEntry.split(/\s+/);
                                const ratingStr = parts.pop();
                                const skillName = parts.join(' ').toLowerCase();

                                const rating = parseInt(ratingStr);
                                if (!isNaN(rating) && skillMap[skillName]) {
                                    const sk = skillMap[skillName];
                                    creature.system.skills[sk.key].rating = rating;
                                    log(`Skill ${sk.key}: ${rating}`);
                                    if (passiveVal !== null && sk.key === "awareness") {
                                        creature.system.combat.passiveAwareness.total = passiveVal;
                                        log(`Passive Awareness: ${passiveVal}`);
                                    }
                                } else if (!isNaN(rating)) {
                                    log(`Unknown skill: ${skillName} ${rating}`);
                                }
                            });
                        }
                        i = j - 1;
                    }

                    if (line.match(/^BONUSES/i)) {
                        let j = i + 1;
                        while (j < lines.length && !isSectionHeader(lines[j])) {
                            const b = lines[j].trim();
                            if (b && b.includes(':')) {
                                const colon = b.indexOf(':');
                                const n = b.substring(0, colon).trim();
                                let c = b.substring(colon + 1).trim();
                                let k = j + 1;
                                while (k < lines.length && !lines[k].match(/^[A-Z][a-zA-Z& \-]*:/) && !isSectionHeader(lines[k])) {
                                    c += ' ' + lines[k].trim(); k++;
                                }
                                creature.items.push(createItem("talent", n, c));
                                log(`BONUS (talent): ${n}`);
                                j = k;
                                continue;
                            }
                            j++;
                        }
                        i = j - 1;
                    }

                    if (line.match(/^(ABILITIES|ACTION:)/i)) {
                        let j = i + 1;
                        while (j < lines.length && !isSectionHeader(lines[j])) {
                            let a = lines[j].trim();
                            if (a.match(/^ACTION:/i)) a = a.replace(/^ACTION:/i, '').trim();
                            if (a.includes(':') && !a.match(/^ACTION:/i)) {
                                const colon = a.indexOf(':');
                                const n = a.substring(0, colon).trim();
                                let c = a.substring(colon + 1).trim();
                                let k = j + 1;
                                while (k < lines.length && !lines[k].match(/^[A-Z][a-zA-Z& \-]*:/) && !isSectionHeader(lines[k])) {
                                    c += ' ' + lines[k].trim(); k++;
                                }
                                if (c.includes('+') && c.includes('/')) creature.items.push(createItem("weapon", n, c));
                                else creature.items.push(createItem("ability", n, c));
                                log(`${c.includes('+') && c.includes('/') ? 'Weapon' : 'Ability'}: ${n}`);
                                j = k;
                                continue;
                            }
                            j++;
                        }
                        i = j - 1;
                    }

                    if (line.match(/^Conviction\s+Resolve\s+Speed/i)) {
                        const vals = nextLine.split(/\s+/).filter(v => v);
                        creature.system.combat.conviction.total = parseInt(vals[0]) || 0;
                        creature.system.combat.resolve.total = parseInt(vals[1]) || 0;
                        creature.system.combat.speed = parseInt(vals[2]) || 6;
                        log(`Conviction/Resolve/Speed: Conv=${vals[0]} Res=${vals[1]} Spd=${vals[2]}`);
                        i++;
                    }

                    if (line.match(/^NOTES/i)) {
                        let notes = "";
                        let j = i + 1;
                        while (j < lines.length && !isSectionHeader(lines[j])) { notes += lines[j].trim() + " "; j++; }
                        notes = notes.trim().replace(/[º~]/g, "<br>");
                        creature.system.notes = `<p>${notes}</p>`;
                        log(`Notes: ${notes.substring(0,50)}...`);
                        i = j - 1;
                    }
                }

                if (threatText) {
                    threatText = threatText.replace(/\s+/g, ' ').trim();
                    log(`Threat keywords text: ${threatText}`);
                    threatText.split(',').forEach(k => {
                        const kw = k.trim();
                        if (kw) { creature.items.push(createItem("keyword", kw, "")); log(`Threat Keyword: ${kw}`); }
                    });
                }

            } catch (e) { log('Error in parsing loop: ' + e.message); }

            document.getElementById('debug').innerText = debugLog.join('\n');
            return creature;
        }

        function log(msg) { debugLog.push(msg); }

        function importCreatures() {
            try {
                const text = document.getElementById('input').value.trim();
                if (!text) return;

                const lines = text.split('\n');
                let blocks = [];
                let currentBlock = [];

                const firstLine = lines.find(l => l.trim());
                const hasSeparator = firstLine && (firstLine.trim().startsWith('º') || firstLine.trim().startsWith('~'));

                let addedCount = creatures.length;

                if (!hasSeparator) {
                    const c = parseCreature(text);
                    if (c) {
                        creatures.push(c);
                    }
                } else {
                    lines.forEach(line => {
                        const trimmed = line.trim();
                        if (trimmed.startsWith('º') || trimmed.startsWith('~')) {
                            if (currentBlock.length > 0) {
                                blocks.push(currentBlock.join('\n'));
                                currentBlock = [];
                            }
                            currentBlock.push(line);
                        } else if (currentBlock.length > 0) {
                            currentBlock.push(line);
                        }
                    });
                    if (currentBlock.length > 0) blocks.push(currentBlock.join('\n'));
                    
                    const newCreatures = blocks.map(block => parseCreature(block)).filter(c => c);
                    creatures = creatures.concat(newCreatures);
                }

                updateTable();
                updateInfo();
                document.getElementById('input').value = '';

                if (creatures.length > addedCount) {
                    showCreatureDetail(creatures.length - 1);
                }
            } catch (e) {
                alert('Error: ' + e.message);
                console.error(e);
            }
        }

        function updateTable() {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            creatures.forEach((c, idx) => {
                const row = tbody.insertRow();
                row.innerHTML = `<td onclick="showCreatureDetail(${idx})" style="cursor:pointer;color:#00ff41;text-decoration:underline;">${c.name}</td>
                                 <td>${c.system.advances.tier}</td><td>${c.items.length}</td>
                                 <td><button onclick="deleteCreature(${idx})">${translations[currentLang].deleteAll.split(' ')[0]}</button></td>`;
            });
        }

        function updateInfo() {
            document.getElementById('info').innerHTML = `${creatures.length} <span data-en="${translations.en.infoCreatures}" data-es="${translations.es.infoCreatures}">${translations[currentLang].infoCreatures}</span>`;
        }

        function clearInput() {
            document.getElementById('input').value = '';
            document.getElementById('debug').innerText = '';
        }

        function clearAll() {
            creatures = [];
            updateTable();
            updateInfo();
            document.getElementById('debug').innerText = '';
        }

        function deleteCreature(idx) { 
            creatures.splice(idx, 1); 
            updateTable(); 
            updateInfo(); 
        }

        function downloadJSON() {
            const id = Math.random().toString(36).substring(2,8).toUpperCase();
            const comp = {
                "package":"world.export",
                "metadata":{
                    "label":`Export ${id}`,
                    "type":"Actor",
                    "name":`export-${id}`,
                    "path":`packs/export-${id}`,
                    "system":"wrath-and-glory",
                    "ownership":{"PLAYER":"OBSERVER","ASSISTANT":"OWNER"},
                    "flags":{},
                    "package":"world",
                    "id":`world.export-${id}`,
                    "packageType":"world",
                    "packageName":"wg"
                },
                "type":"Actor",
                "items":creatures,
                "source":{"world":"wg","system":"wrath-and-glory","version":{"core":"13.350","system":"7.3.0"}},
                "folders":[]
            };
            const blob = new Blob([JSON.stringify(comp,null,2)],{type:'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = `compendio-${id}-${Date.now()}.json`; a.click();
        }

        function copyJSON() {
            const id = Math.random().toString(36).substring(2,8).toUpperCase();
            const comp = {
                "package":"world.export",
                "metadata":{
                    "label":`Export ${id}`,
                    "type":"Actor",
                    "name":`export-${id}`,
                    "path":`packs/export-${id}`,
                    "system":"wrath-and-glory",
                    "id":`world.export-${id}`
                },
                "type":"Actor",
                "items":creatures,
                "source":{"world":"wg","system":"wrath-and-glory","version":{"core":"13.350","system":"7.3.0"}},
                "folders":[]
            };
            navigator.clipboard.writeText(JSON.stringify(comp,null,2));
            alert(translations[currentLang].copy + ' JSON');
        }

        function showCreatureDetail(idx) {
            const c = creatures[idx];
            const a = c.system.attributes, com = c.system.combat;
            const t = translations[currentLang];
            let d = `\n${'═'.repeat(80)}\n ${c.name}\n${'═'.repeat(80)}\n`;
            d += `Tier:${c.system.advances.tier} | Rank:${c.system.advances.rank} | ID:${c._id.substring(0,8)}...\n\n`;
            d += `ATTRIBUTES:\n STR:${a.strength.base} | TOU:${a.toughness.base} | AGI:${a.agility.base} | INI:${a.initiative.base} | WIL:${a.willpower.base} | INT:${a.intellect.base} | FEL:${a.fellowship.base}\n\n`;
            d += `COMBAT:\n Defence:${com.defence.total} | Wounds:${com.wounds.value}/${com.wounds.max} | Shock:${com.shock.value}/${com.shock.max}\n`;
            d += ` Resilience:${com.resilience.total} | Conviction:${com.conviction.total} | Resolve:${com.resolve.total} | Speed:${com.speed} | Size:${com.size}\n`;
            d += ` Passive Awareness: ${com.passiveAwareness.total}\n\n`;
            if (c.system.bio.faction) d += `KEYWORDS: ${c.system.bio.faction}\n\n`;

            const skills = Object.entries(c.system.skills).filter(([_,s]) => s.rating > 0);
            if (skills.length) {
                d += `SKILLS:\n`;
                let cnt = 0;
                skills.forEach(([k,s]) => {
                    d += ` ${t.skills[k] || k}:${s.rating}`; cnt++;
                    d += (cnt % 5 === 0) ? `\n` : ` | `;
                });
                if (cnt % 5 !== 0) d += '\n'; d += '\n';
            }

            if (c.items.length) {
                d += `EQUIPMENT (${c.items.length} items):\n`;
                ['weapon','armour','ability','talent','keyword'].forEach(type => {
                    const list = c.items.filter(i => i.type === type);
                    if (!list.length) return;
                    const title = t.sections[type === 'weapon' ? 'WEAPONS' : type === 'armour' ? 'ARMOUR' : type.toUpperCase()] || type.toUpperCase();
                    d += `\n [${title}] (${list.length}):\n`;
                    list.forEach(it => {
                        if (type === 'keyword') d += ` ${it.name}`;
                        else d += ` • ${it.name}`;
                        const desc = it.system.description?.replace(/<[^>]*>/g, '').substring(0,100) || '';
                        if (desc) d += ` ${desc}${desc.length===100?'...':''}`;
                        d += '\n';
                    });
                    if (type === 'keyword') d += '\n';
                });
                d += '\n';
            }

            if (c.system.notes) {
                const plain = c.system.notes.replace(/<br>/g,'\n').replace(/<[^>]*>/g,'').trim();
                if (plain) d += `NOTES:\n${wordWrap(plain,60)}\n\n`;
            }
            d += `${'═'.repeat(80)}\n`;
            document.getElementById('debug').innerText = d;
        }

        function wordWrap(text, max) {
            const paras = text.split('\n');
            return paras.map(p => {
                const words = p.split(' ');
                let lines = [], cur = '';
                words.forEach(w => {
                    if (cur.length + w.length + 1 > max) { lines.push(cur); cur = w; }
                    else cur += (cur ? ' ' : '') + w;
                });
                if (cur) lines.push(cur);
                return lines.join('\n');
            }).join('\n');
        }

        document.getElementById('importBtn').addEventListener('click', importCreatures);
        document.getElementById('clearBtn').addEventListener('click', clearInput);
        document.getElementById('clearAllBtn').addEventListener('click', clearAll);
        document.getElementById('downloadBtn').addEventListener('click', downloadJSON);
        document.getElementById('copyBtn').addEventListener('click', copyJSON);

        updateHints();
    </script>
</body>
</html>
